#!/bin/ash

# Installer generated by FirmwarePackager.
# Verifies files listed in manifest.tsv using MD5 hashes and performs
# atomic updates with rollback support.

set -eu

PKG_ID="@PKG_ID@"
PKG_NAME="@PKG_NAME@"
PKG_VERSION="@PKG_VERSION@"

STATE_DIR="/opt/upgrade/state"
PKG_DIR="/opt/upgrade/packages"
BACKUP_DIR="/opt/upgrade/backup/${PKG_ID}"
STATE_FILE="${STATE_DIR}/${PKG_ID}.state"
JOURNAL_DIR="/opt/upgrade/journal"
JOURNAL_FILE="${JOURNAL_DIR}/${PKG_ID}.journal"
PKG_TGZ="${PKG_DIR}/${PKG_ID}.tar.gz"
LOCK_DIR="/opt/upgrade/locks"
LOCK_FILE="${LOCK_DIR}/upgrade.lock"
LAST_DIR="/opt/upgrade/last"

PKG_ROOT=$(cd "$(dirname "$0")/.." && pwd)

LOG_DIR="/opt/upgrade/logs"
LOG_TS="$(date +%Y%m%d%H%M%S)"
LOG_FILE="${LOG_DIR}/${PKG_ID}-${LOG_TS}.log"

log() {
    mkdir -p "$LOG_DIR"
    printf '%s %s\n' "$(date '+%Y-%m-%dT%H:%M:%S%z')" "$*" | tee -a "$LOG_FILE"
}

STEP=""
LAST_FILE=""
STORE=""
RESUME=0
STATUS="IN_PROGRESS"

while [ $# -gt 0 ]; do
    case "$1" in
        --resume)
            RESUME=1
            ;;
        --store)
            STORE="$2"
            shift
            ;;
        *)
            log "Usage: $0 [--resume] [--store <archive>]" >&2
            exit 1
            ;;
    esac
    shift
done

write_state() {
cat >"$STATE_FILE" <<STATE
STEP=$STEP
JOURNAL=$JOURNAL_FILE
PKG_TGZ=$PKG_TGZ
LAST_FILE=$LAST_FILE
STATUS=$STATUS
STATE
}

rollback() {
    [ -f "$JOURNAL_FILE" ] || return 0
    awk '{l[NR]=$0} END{for(i=NR;i>=1;i--) print l[i]}' "$JOURNAL_FILE" | \
    while IFS="|" read -r action dest backup; do
        case "$action" in
            REPLACED)
                if [ -n "$backup" ] && [ -f "$backup" ]; then
                    mv "$backup" "$dest"
                elif [ -f "$dest.old" ]; then
                    mv "$dest.old" "$dest"
                else
                    rm -f "$dest"
                fi
                ;;
            BACKUP)
                if [ -n "$backup" ] && [ -f "$backup" ]; then
                    mv "$backup" "$dest"
                elif [ ! -e "$dest" ] && [ -f "$dest.old" ]; then
                    mv "$dest.old" "$dest"
                fi
                rm -f "$dest.old"
                ;;
        esac
    done
}

acquire_lock() {
    ln -s "$$" "$LOCK_FILE" 2>/dev/null
}

release_lock() {
    rm -f "$LOCK_FILE"
}

fail() {
    trap - EXIT
    STEP="FAILED"
    STATUS="FAIL"
    write_state
    rollback
    release_lock
    exit 1
}

cleanup_success() {
    if [ -f "$BASE_DIR/manifest.tsv" ]; then
        {
            read -r _header
            while IFS="$(printf '\t')" read -r _rel dest _rest; do
                if [ -n "$dest" ] && [ "${dest#\#}" = "$dest" ]; then
                    rm -f "$dest.old"
                fi
            done
        } < "$BASE_DIR/manifest.tsv"
    fi
    rm -f "$JOURNAL_FILE" "$STATE_FILE" "$PKG_TGZ"
    rm -rf "$BACKUP_DIR"
    release_lock
}

trap fail INT TERM HUP QUIT
trap fail EXIT

mkdir -p "$STATE_DIR" "$JOURNAL_DIR" "$PKG_DIR" "$BACKUP_DIR" "$LOCK_DIR"
if ! acquire_lock; then
    log "Another upgrade is in progress" >&2
    exit 1
fi

if [ "$RESUME" -eq 1 ]; then
    [ -f "$STATE_FILE" ] || exit 1
    . "$STATE_FILE"
    JOURNAL_FILE="$JOURNAL"
    [ -f "$JOURNAL_FILE" ] || : > "$JOURNAL_FILE"
    if [ "$STEP" != "DONE" ]; then
        rollback
        : > "$JOURNAL_FILE"
        STEP="PREPARE"
        LAST_FILE=""
        STATUS="IN_PROGRESS"
        write_state
    fi
else
    : > "$JOURNAL_FILE"
    STEP="PREPARE"
    STATUS="IN_PROGRESS"
    write_state
fi

if [ "$STEP" = "PREPARE" ]; then
    if [ -n "$STORE" ]; then
        cp "$STORE" "$PKG_TGZ"
    else
        pkg_parent=$(cd "$PKG_ROOT/.." && pwd)
        src=$(ls "$pkg_parent"/*.tar.gz 2>/dev/null | head -n 1)
        if [ -n "$src" ] && [ -f "$src" ]; then
            cp "$src" "$PKG_TGZ"
        fi
    fi
    STEP="BACKUP"
    write_state
fi

BASE_DIR="$PKG_ROOT"
# Step 2: make recovery scripts available in the last directory
mkdir -p "$LAST_DIR"
rm -rf "$LAST_DIR/scripts"
cp -r "$BASE_DIR/scripts" "$LAST_DIR/"

HOOK_SRC="$LAST_DIR/scripts/init/sysv/S95-upgrade-recover"
if [ -f "$HOOK_SRC" ]; then
    mkdir -p /etc/init.d /etc/rcS.d
    cp "$HOOK_SRC" /etc/init.d/
    chmod +x /etc/init.d/S95-upgrade-recover 2>/dev/null || true
    if [ ! -e /etc/rcS.d/S95-upgrade-recover ]; then
        ln -s ../init.d/S95-upgrade-recover /etc/rcS.d/S95-upgrade-recover
    fi
fi

if [ "$STEP" = "BACKUP" ]; then
    SKIP=0
    if [ "$RESUME" -eq 1 ] && [ -n "$LAST_FILE" ]; then
        SKIP=1
    fi
    {
        read -r _header
        while IFS="$(printf '\t')" read -r rel dest mode owner group md5; do
            if [ -z "$rel" ] || [ "${rel#\#}" != "$rel" ]; then
                continue
            fi
            if [ "$SKIP" -eq 1 ]; then
                if [ "$dest" = "$LAST_FILE" ]; then
                    SKIP=0
                else
                    continue
                fi
            fi
            LAST_FILE="$dest"
            write_state

            calc=$(md5sum "$BASE_DIR/payload/$rel" | awk '{print $1}')
            [ "$calc" = "$md5" ] || fail

            ddir=$(dirname "$dest")
            mkdir -p "$ddir"

            backup=""
            if [ -f "$dest" ]; then
                backup="$BACKUP_DIR/$dest"
                mkdir -p "$(dirname "$backup")"
                cp "$dest" "$backup"
                sync
                mv "$dest" "$dest.old"
                sync
                echo "BACKUP|$dest|$backup" >> "$JOURNAL_FILE"
            fi

            cp "$BASE_DIR/payload/$rel" "$dest.new"
            sync
            chmod "$mode" "$dest.new" 2>/dev/null || true
            if [ -n "$owner" ] && [ -n "$group" ]; then
                chown "$owner:$group" "$dest.new" 2>/dev/null || true
            fi
            calc_new=$(md5sum "$dest.new" | awk '{print $1}')
            [ "$calc_new" = "$md5" ] || fail
            mv "$dest.new" "$dest"
            sync
            calc_final=$(md5sum "$dest" | awk '{print $1}')
            [ "$calc_final" = "$md5" ] || fail
            echo "REPLACED|$dest|$backup" >> "$JOURNAL_FILE"

        done
        sync
    } < "$BASE_DIR/manifest.tsv"
    STEP="COMMIT"
    write_state
fi

trap - EXIT
STEP="DONE"
LAST_FILE=""
STATUS="SUCCESS"
write_state
cleanup_success
exit 0
