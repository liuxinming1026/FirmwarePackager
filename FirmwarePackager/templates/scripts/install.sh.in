#!/bin/ash

# Installer generated by FirmwarePackager.
# Verifies files listed in manifest.tsv using MD5 hashes and performs
# atomic updates with rollback support.

set -e

PKG_ID="@PKG_ID@"
PKG_NAME="@PKG_NAME@"
PKG_VERSION="@PKG_VERSION@"

STATE_DIR="/opt/upgrade/state"
PKG_DIR="/opt/upgrade/packages"
BACKUP_DIR="/opt/upgrade/backup/${PKG_ID}"
STATE_FILE="${STATE_DIR}/${PKG_ID}.state"
JOURNAL="${STATE_DIR}/${PKG_ID}.journal"
PKG_TGZ="${PKG_DIR}/${PKG_ID}.tar.gz"
LOCK_DIR="/opt/upgrade/locks"
LOCK_FILE="${LOCK_DIR}/upgrade.lock"

STATUS="INIT"
STEP=""
LAST_FILE=""
STORE=""
RESUME=0

while [ $# -gt 0 ]; do
    case "$1" in
        --resume)
            RESUME=1
            ;;
        --store)
            STORE="$2"
            shift
            ;;
        *)
            echo "Usage: $0 [--resume] [--store <archive>]" >&2
            exit 1
            ;;
    esac
    shift
done

write_state() {
cat >"$STATE_FILE" <<STATE
STATUS=$STATUS
STEP=$STEP
JOURNAL=$JOURNAL
PKG_TGZ=$PKG_TGZ
LAST_FILE=$LAST_FILE
STATE
}

rollback() {
    [ -f "$JOURNAL" ] || return 0
    awk '{l[NR]=$0} END{for(i=NR;i>=1;i--) print l[i]}' "$JOURNAL" | \
    while IFS="|" read -r action dest backup; do
        case "$action" in
            REPLACED)
                if [ -n "$backup" ] && [ -f "$backup" ]; then
                    mv "$backup" "$dest"
                elif [ -f "$dest.old" ]; then
                    mv "$dest.old" "$dest"
                else
                    rm -f "$dest"
                fi
                ;;
            BACKUP)
                if [ -n "$backup" ] && [ -f "$backup" ]; then
                    mv "$backup" "$dest"
                elif [ ! -e "$dest" ] && [ -f "$dest.old" ]; then
                    mv "$dest.old" "$dest"
                fi
                rm -f "$dest.old"
                ;;
        esac
    done
}

fail() {
    trap - EXIT
    STATUS="FAIL"
    STEP="rollback"
    write_state
    rollback
    flock -u 9 2>/dev/null || true
    rm -f "$LOCK_FILE"
    exit 1
}

cleanup_success() {
    if [ -f "$BASE_DIR/manifest.tsv" ]; then
        {
            read -r _header
            while IFS="$(printf '\t')" read -r _rel dest _rest; do
                if [ -n "$dest" ] && [ "${dest#\#}" = "$dest" ]; then
                    rm -f "$dest.old"
                fi
            done
        } < "$BASE_DIR/manifest.tsv"
    fi
    rm -f "$JOURNAL" "$PKG_TGZ"
    rm -rf "$BACKUP_DIR"
    flock -u 9 2>/dev/null || true
    rm -f "$LOCK_FILE"
}

trap fail INT TERM HUP QUIT
trap fail EXIT

mkdir -p "$STATE_DIR" "$PKG_DIR" "$BACKUP_DIR" "$LOCK_DIR"
exec 9>"$LOCK_FILE"
if ! flock -n 9; then
    echo "Another upgrade is in progress" >&2
    exit 1
fi

if [ "$RESUME" -eq 1 ]; then
    [ -f "$STATE_FILE" ] || exit 1
    . "$STATE_FILE"
    [ -f "$JOURNAL" ] || : > "$JOURNAL"
else
    : > "$JOURNAL"
    STATUS="RUNNING"
    STEP="store"
    write_state
    if [ -n "$STORE" ]; then
        cp "$STORE" "$PKG_TGZ"
    fi
    STEP="install"
    write_state
fi

BASE_DIR=$(cd "$(dirname "$0")/.." && pwd)

if [ "$STEP" = "install" ]; then
    SKIP=0
    if [ "$RESUME" -eq 1 ] && [ -n "$LAST_FILE" ]; then
        SKIP=1
    fi
    {
        read -r _header
        while IFS="$(printf '\t')" read -r rel dest mode owner group md5; do
            if [ -z "$rel" ] || [ "${rel#\#}" != "$rel" ]; then
                continue
            fi
            if [ "$SKIP" -eq 1 ]; then
                [ "$dest" = "$LAST_FILE" ] && SKIP=0
                continue
            fi
            LAST_FILE="$dest"
            write_state

            calc=$(md5sum "$BASE_DIR/$rel" | awk '{print $1}')
            [ "$calc" = "$md5" ] || fail

            ddir=$(dirname "$dest")
            mkdir -p "$ddir"

            backup=""
            if [ -f "$dest" ]; then
                backup="$BACKUP_DIR/$dest"
                mkdir -p "$(dirname "$backup")"
                cp "$dest" "$backup"
                mv "$dest" "$dest.old"
                echo "BACKUP|$dest|$backup" >> "$JOURNAL"
            fi

            cp "$BASE_DIR/$rel" "$dest.new"
            chmod "$mode" "$dest.new" 2>/dev/null || true
            if [ -n "$owner" ] && [ -n "$group" ]; then
                chown "$owner:$group" "$dest.new" 2>/dev/null || true
            fi
            calc_new=$(md5sum "$dest.new" | awk '{print $1}')
            [ "$calc_new" = "$md5" ] || fail
            mv "$dest.new" "$dest"
            calc_final=$(md5sum "$dest" | awk '{print $1}')
            [ "$calc_final" = "$md5" ] || fail
            echo "REPLACED|$dest|$backup" >> "$JOURNAL"

        done
    } < "$BASE_DIR/manifest.tsv"
fi

trap - EXIT
STATUS="SUCCESS"
STEP="done"
LAST_FILE=""
write_state
cleanup_success
exit 0
